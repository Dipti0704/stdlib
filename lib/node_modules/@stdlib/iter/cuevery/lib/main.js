/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var setReadOnly = require( '@stdlib/utils/define-nonenumerable-read-only-property' );
var isIteratorLike = require( '@stdlib/assert/is-iterator-like' );
var isFunction = require( '@stdlib/assert/is-function' );
var iteratorSymbol = require( '@stdlib/symbol-iterator' );
var format = require( '@stdlib/string/format' );


// MAIN //

/**
* Returns an iterator which cumulatively tests whether every iterated value is truthy.
*
* @param {Iterator} iterator - input iterator
* @throws {TypeError} must provide an iterator
* @returns {Iterator} iterator
*
* @example
* var array2iterator = require( '@stdlib/array-to-iterator' );
*
* var it = iterCuEvery( array2iterator( [ true, true, true, false, true ] ) );
* // returns <Object>
*
* var v = it.next().value;
* // returns true
*
* v = it.next().value;
* // returns true
*
* v = it.next().value;
* // returns true
*
* v = it.next().value;
* // returns false
*
* v = it.next().value;
* // returns false
*
* var bool = it.next().done;
* // returns true
*/


function iterCuEvery(iterator) {
    if (!isIteratorLike(iterator)) {
        throw new TypeError(format('invalid argument. Must provide an iterator. Value: `%s`.', iterator));
    }

    var FLG = true; // Assume all values are truthy initially
    var done = false;

    var iter = {
        next: next,
        return: finish
    };

    if (iteratorSymbol && isFunction(iterator[iteratorSymbol])) {
        setReadOnly(iter, iteratorSymbol, factory);
    }

    return iter;

    function next() {
        if (done) {
            return {
                value: FLG,
                done: true
            };
        }
        var v = iterator.next();
        if (v.done) {
            done = true;
            return {
                value: FLG,
                done: true
            };
        }
        if (!v.value) {
            FLG = false;
            done = true; // Short-circuit once a falsy value is found
            return {
                value: FLG,
                done: true
            };
        }
        return {
            value: FLG,
            done: false
        };
    }

    function finish(value) {
        done = true;
        if (arguments.length) {
            return {
                value: value,
                done: true
            };
        }
        return {
            value: FLG,
            done: true
        };
    }

    function factory() {
        return iterCuEvery(iterator[iteratorSymbol]());
    }
}

// EXPORTS //

module.exports = iterCuEvery;